<!-- uses https://highlightjs.org/
-->

<html>

<head>
	<script type="text/javascript">
		var codeType = "C++"
	</script>
	<script src="../../../site/highlight.pack.js"></script>
	<link rel="stylesheet" href="../../../site/highlight_styles/xcode.css">
	<link rel="stylesheet" href="../../../site/weekly.css">
	<script type="text/javascript" src="../../../site/weekly.js"></script>
	

</head>

<body onload="fetchSource()">
	<div class="hero-image">
		<div class="hero-text">
			<h1>CSE 121a: Week 02</h1>
			<p>The Fundamentals</p>
		</div>
	</div>
	<h1>Similarities and Differences</h1>
	<h3>Operators and Functions</h3>
	<p>Remember, Python has C as one of its ancestors. Because of this, it is not shocking to find out that 
		Python inherited many of its operators directly from C. Since Clojure does not have C as an ancestor, 
		it should come as no supprise that it has no operators at all, an operator being a C concept and construct. 
	</p>
	<p>Don't get the wrong idea. Each of these behaviors can be done in Clojure, they will just be done differently. Take a look
	at Table 1 to see how.</p>
	<p>
		<table class="blueTable">
			<caption>Table 1: Clojure Equivalents of Python Operators</caption>
			<thead>
				<tr>
					<th>Python</th>
					<th>Clojure</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>a+b+c</td><td>(+ a b c)</td>
				</tr>
				<tr>
					<td>a-b-c</td><td>(- a b c)</td>
				</tr>
				<tr>
					<td>a/b/c</td><td>(/ a b c)</td>
				</tr>
				<tr>
					<td>a*b*c</td><td>(* a b c)</td>
				</tr>
				<tr>
					<td>a+=1</td><td>N/A</td>
				</tr>
				<tr>
					<td>a-=1</td><td>N/A</td>
				</tr>
				<tr>
					<td>N/A</td><td>(inc a)</td>
				</tr>
				<tr>
					<td>N/A</td><td>(dec a)</td>
				</tr>
				<tr>
					<td>N/A</td><td>(max 1 2 3)</td>
				</tr>
				<tr>
					<td>N/A</td><td>(min 1 2 3)</td>
				</tr>

				<tr>
					<td>a % b</td><td>(rem a b)</td>
				</tr>
				<tr>
					<td>a**b</td><td>(math/expt a b)</td>
				</tr>
				<tr>
					<td>a//b</td><td>(Math/floor (/ a b))</td>
				</tr>
				<tr>
					<td>a == b</td><td>(= a b)</td>
				</tr>
				<tr>
					<td>a != b</td><td>(not (= a b)</td>
				</tr>
				<tr>
					<td>a &lt&gt b</td><td>N/A</td>
				</tr>
				<tr>
					<td>a &gt b</td><td>(&gt a b)</td>
				</tr>
				<tr>
					<td>a &gt= b</td><td>(&gt= a b)</td>
				</tr>
				<tr>
					<td>a &lt b</td><td>(&lt a b)</td>
				</tr>
				<tr>
					<td>a &lt= b</td><td>(&lt= a b)</td>
				</tr>
				<tr>
					<td>a and b</td><td>(and a b)</td>
				</tr>

				<tr>
					<td>a or b</td><td>(or a b)</td>
				</tr>
				<tr>
					<td>not(a and b)</td><td>(not (and a b)</td>
				</tr>
			</tbody>
		</table>
	</p>
	<p>The Clojure syntax examples you see in the table above use a function instead of an operator. You'll learn a lot more about functions next week 
	so don't get too worried if you don't understand much about them yet.
	</p>
	<h3>Variables...or Not???</h3>
	<p>Python has variables. This is valid Python code.</p>
	<pre>
<code class="Python">age = 3
age = 5
age = 4.2</code>
	</pre>
	</p>
	<p>Clojure is different. In Clojure you don't assign values to variables. That's why there are no assignment operators in Clojure. Instead of 
		assigning, you bind names to values. This is not just semantics. 
		Once a name is bound to a value, you can not vary the value.
	This is a valid Clojure name-value binding for a few types of values.</p>
	<pre>
<code>(def age 3)
(def height 2.53)
(def name "Sue")</code>
	</pre>
	<p>
		To do this, you use the def function to define the name-value binding. The first parameter of the def function is the name to be bound to. 
		The second is the value to bind to the name. As with all things, there are pluses and minuses to having immutable bindings. A plus is that 
		you never have to check if a value has been bound. This dramatically reduces the amount of error checking code you have to write. The only 
		negative is that you have to learn to think differently if you are coming from a background of languages that have variables. It doesn't 
		take too long to make this change, if you open up your mind to possibilities.
	</p>
	<h4>Some Common, Valid, Clojure Variable Types</h4>
	<p>Basic Integer Types
	<ul>
		<li>Integer</li>
		<li>Octal (0152)</li>
		<li>Hexadecimal (0xff)</li>
		<li>Radix - any base (2r1101, 3r11012)</li>

	</ul></p>
	<p>Basic Floating Point Types
		<ul>
			<li>floating point (32.5 or 3.25e1</li>
		</ul>
	</p>
	<p>Basic Rational Types - used to accurately describe fractions where the numerator and denominator are integers.
		<ul>
			<li>rational (1/3 or 5/4)</li>
		</ul>
	</p>
	<p>Boolean Types
		<ul>
			<li>Boolean</li>
		</ul>
	</p>
	<p>Character Types
		<ul>
			<li>char - single character</li>
			<li>String</li>
		</ul>
	</p>
	</pre>
	<p>
		Be careful. It is tempting to think, "Hey...those floating point numbers look like they could hold bigger integers than an integer can. Maybe I'll just use them." Such a thought would lead you 
	down a path you do not want to be on. Beginning programmers tend to think of floating point numbers as being a coninuous number line. They are not. There are 
	numbers that a floating point number can not represent. There are gaps in the floating point numbers on all computers in all languages and the larger the integer you 
	try to represent, the higher the probability that adding 1 to that number will result in the original number.
	</p>
	<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</body>
</html>
