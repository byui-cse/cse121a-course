<!-- uses https://highlightjs.org/
-->

<html>

<head>
	<link rel="shortcut icon" href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico" type="image/x-icon">
    <script type="text/javascript">
                 var codeType = "Clojure"
    </script>
    <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
    <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css">
    <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/weekly.css">
    <script type="text/javascript" src="https://byui-cse.github.io/Language-Courses/site/weekly.js"></script>

</head>

<body onload="fetchSource()">
<div class="hero-image">
  <div class="hero-text">
    <h1>CSE 121a: Week 01</h1>
    <p>Installation and Purpose</p>
  </div>
</div>
	<h1>The Why of Clojure</h1>
	<h3>Some Background</h3>
	<p>Clojure is a dialect of Lisp, a language designed in 1958 and still in use.
	Because Lisp was created so long ago, there are concepts in computing that are
	now common, but didn&rsquo;t exist way back then. For example, parallel
	computing was not a thing so Lisp doesn&rsquo;t have parallel computing
	&lsquo;baked in&rsquo; from the beginning. It has been added, but since it is
	added on, it can be somewhat clunky. Clojure, on the other hand, was designed
	to leverage what is good about Lisp and the parallelism available in the Java
	Virtual Machine. Clojure was also designed to be a functional programming
	language, making parallel programming safer and easier.</p>
	<p>
		Clojure being one of many functional programming language means that, in
		Clojure, collections of data and individual pieces of data are immutable. In
		other words, there are no variables in Clojure. While this may come as a
		shock to you because of your Python background, it is a completely valid way
		of writing very good code. It also means that you can write parallel code
		without creating the two huge, common problems in parallel code written for
		languages that have variables, <a href="https://stackoverflow.com/questions/34510/what-is-a-race-condition">race conditions</a>
		and <a href="https://stackoverflow.com/questions/34512/what-is-a-deadlock">cross or dead-locks</a>. Thankfully, Clojure and other functional
		programming languages don&rsquo;t have variables, and so it&rsquo;s impossible to create either of these problems.
	</p>
	<p>
		Another advantage of being a functional programming language is that
		functions are and can be treated just like data. You can pass a function as
		a parameter, you can return a function from a call to a different function,
		and many other very cool things. This means that functions like map, filter,
		and reduce, you saw these in Python, are no different than any other
		function you can create, and you don&rsquo;t need that weird lambda keyword
		that Python has. Also, since functions are data, you can put functions in
		lists and maps. When done well, this makes your code extremely flexible and
		powerful.</p>
	<h3>Python and Clojure are Related</h3>
	<p>Take a look at Figure 1. It shows the ancestry of both Clojure and Python.
	Since Clojure and Python share some ancestry, you can expect to see echos of
	things in Python in Clojure. An example of this is the concept of a range.
	However, Python is not Clojure&rsquo;s only ancestor, nor its most significant
	one. The strongest contributor is Lisp, followed closely by Haskell, so you
	can expect to see Lisp-ish syntax that is significantly different than what
	you learned for Python.</p>

<figure>

  <img src="images/python_clojure_lang_history.png" alt="ancestors specific to Python. Modula 3, Pascal, ANSI C, C, B, BCPL. ancestors specific to Clojure. Haskell, Scheme, Lisp. Ancestors common to both languages. Algol 68, Algol 58, Fortran.">
  <figcaption>Figure 1. - The anticedent languages for Python and Clojure (Grady Booch and others).</figcaption>
</figure>

<h1>Installation</h1>
	<h2>The Virtual Machine</h2>
	<p>If it isn't already installed on your machine, start by installing <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html"> the JDK</a> 
		(Java Developer Kit) for your computer. The link leads you to download an installer. Run the installer using the default values the installer suggests. 
		The JDK includes the Virtual Machine, not a real piece of hardware, that your Clojure code will run on. By leveraging this VM, your clojure code won't need 
		to be compiled to run on your specific hardware.
	<h2>Development Tools</h2>
	<p>While there are many editors and IDE's that can be used to write Clojure, it was decided not to hide the Clojure toolset from you. <a href="https://clojure.org/guides/getting_started">Follow the download instructions for your OS 
	at the clojure.org site</a>. After you complete this task, you are ready to start using Clojure!</p>
	<h3>Running the REPL</h3>
		<p>The clj tool is the Clojure REPL (Read-Eval-Print-Loop. This is much like the Python REPL. That means you can type in valid Clojure and execute it 
		just like you could in the Python REPL. Once your installation is complete, open your terminal app (MacOS and Linux) or your command shell (Windows). From now on, in this class, either of these will be called your shell. Type clj into your shell and hit enter. This should appear in your REPL.
	</p>
	<p><pre><code class="Bash">clj
Clojure 1.10.1
user=&gt;</code></pre></p>
	<p>It's fine if there are a few download messages in addition to what's listed here. That's just the toolset updating itself.</p>

	<p>As a preview of things to come, let's use the REPL to add together four numbers, 1,2,3, and 4. Type into the REPL (+ 1 2 3 4) and hit enter. Your REPL will update with the following.</p>
	<p><pre><code class="Bash">user=&gt;(+ 1 2 3 4)
10
user=&gt;</code></pre></p>
	<p>
		In this simple example the impact of having Lisp as Clojure's strongest ancestor instead of C becomes apparent. Python's + operator is borrowed from and acts much like the + operator in C. Clojure doesn't 
		have a + operator. Instead it has a + function. We'll get into this in detail later, but what you've done in this code is pass multiple parameters, the numbers 1, 2, 3, and 4, to 
		Clojure's + function. This is, after all, a functional programming language so you can expect it to use functions whenever possible. &#128525
	</p>
	<p>Also notice that Clojure doen't have commas seperating the parameters where as Python does. Python borrowed that syntax from C.</p>
	<p>Any time you want to terminate the REPL, type control-d. The REPL will stop, and you will be back in your terminal.</p>
<h1>Your First Project</h1>
	<p>Using your operating system tools, create a folder to hold all of your work for this class. Inside that folder, create another folder. Call it <kbd>week01</kbd>. Go back into your shell, restarting it if you closed it, and change directories into the <kbd>week01</kbd> folder. You are almost ready for the next step. Keep up the good work. &#128077;</p>
	<p>Using any text editor of your choice, yes even Visual Studio Code from your Python class would work, create a file 
	named <kbd>first.clj</kbd>. Make sure you save it in the <kbd>week01</kbd> folder. Into this file enter the following
	code and save the changes.
	<p><pre><code class="Clojure">;;A definition for the function hello. This function prints out hello world.
(defn hello []
    (print "Hello World!\n"))
)</code></pre></p>
<p>Don't get deeply worried about what this code does for right now. You'll learn about these things later in the class.</p>
<p>You are now ready to run your first Clojure code! In your shell type either <kbd>ls</kbd> (MacOS,Linux) or <kbd>dir</kbd> (Windows). You should see the file <kbd>first.clj</kbd> listed. If not, you need to change directories into the folder you 
created, <kbd>week01</kbd>. Go back up to those instructions above and try again. After you enter <kbd>ls</kbd> 
(MacOS,Linux) or <kbd>dir</kbd> (Windows), and see <kbd>first.clj</kbd>, start the REPL using <kbd>clj</kbd>.</p>
<p><pre><code class="Bash">clj
Clojure 1.10.1
user=&gt;</code></pre></p>
<p>Now enter <kbd>(load-file "first.clj")</kbd> and hit enter. If you put the code requested into the <kbd>first.clj</kbd> 
	file, the REPLE will update like this.
</p>
<p><pre><code class="Bash">user=> (load-file "first.clj")
#'user/hello
user=></code></pre></p>
<p>
	You are now ready to run the code you wrote. Enter <kbd>(hello)</kbd> and once again press the enter key. Your 
	REPL updates once again.
</p>
<p><pre><code class="Bash">user=> (load-file "first.clj")
#'user/hello
user=>(hello)
Hello World!</code></pre></p>
<p>
<h1>Done!</h1>
<p>Congrats!!! You're all set up and ready to go. If you want to see all the Built-In Functions, BIF's, that pre-exist as part 
	of Clojure available for you to use, <a href="https://clojure.github.io/clojure/clojure.core-api.html">take a look at the 
	Clojure API</a>.</p>
<h1>Appendix</h1>
<p>There are many IDE's and plugins for text editors available for Clojure. If you prefer, you can explore and experiment 
with those tools. More than likely, your favorite text editor has a Clojure plugin. These are not required for the 
course, but if you would like to use them to do things like step-wise debugging, feel free though don't feel like you need to.</p>

<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</body>
</html>
